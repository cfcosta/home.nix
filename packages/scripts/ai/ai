#!/usr/bin/env python

import os
import sys
from pathlib import Path
from typing import Optional, Set


def get_base_command() -> str:
    """Get the base command name from the script name."""
    return Path(__file__).stem


def find_executables() -> Set[str]:
    """Find all {base}-* executables in PATH."""
    commands: Set[str] = set()
    base_cmd: str = get_base_command()
    prefix: str = f"{base_cmd}-"

    for path in os.environ.get("PATH", "").split(os.pathsep):
        if not path:
            continue
        path_dir = Path(path)
        if not path_dir.is_dir():
            continue

        for item in path_dir.iterdir():
            if item.name.startswith(prefix) and os.access(item, os.X_OK):
                cmd_name = item.name[len(prefix) :]  # Remove '{base}-' prefix
                commands.add(cmd_name)

    return commands


def main() -> None:
    """Main entry point."""
    commands = find_executables()

    if not commands:
        print("No AI commands found", file=sys.stderr)
        sys.exit(1)

    if len(sys.argv) < 2:
        print("Available commands:")
        for cmd in commands:
            print(f"  {cmd}")
        sys.exit(1)

    subcommand: str = sys.argv[1]
    args = sys.argv[2:]
    base_cmd: str = get_base_command()

    executable: Optional[Path] = None
    for path in os.environ.get("PATH", "").split(os.pathsep):
        if not path:
            continue
        candidate = Path(path) / f"{base_cmd}-{subcommand}"

        if candidate.exists() and os.access(candidate, os.X_OK):
            executable = candidate
            break

    if not executable or not executable.exists() or not os.access(executable, os.X_OK):
        print(f"Error: No command found for '{subcommand}'", file=sys.stderr)
        sys.exit(1)

    os.execv(executable, [str(executable)] + args)


if __name__ == "__main__":
    main()
